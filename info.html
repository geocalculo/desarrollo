<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>GeoIPT - Reporte del punto consultado</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, Helvetica, Arial, sans-serif;
      background: #e5e7eb;
      color: #0f172a;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem 0.5rem;
    }

    .page {
      width: 100%;
      max-width: 1000px;
    }

    #report-wrapper {
      background: #f9fafb;
      border-radius: 1.5rem;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.18);
      padding: 2rem 2.5rem;
    }

    @media (max-width: 640px) {
      #report-wrapper {
        padding: 1.5rem 1.25rem;
        border-radius: 0.75rem;
      }
    }

    h1 {
      font-size: 1.6rem;
      margin-bottom: 0.75rem;
    }

    .coords-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      font-size: 0.9rem;
      color: #4b5563;
      margin-bottom: 1.5rem;
    }

    .coords-block strong {
      display: block;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #6b7280;
      margin-bottom: 0.25rem;
    }

    .coords-block span {
      display: inline-block;
      margin-right: 0.35rem;
    }

    h2 {
      font-size: 1.1rem;
      margin: 1.25rem 0 0.35rem;
    }

    .tip {
      font-size: 0.75rem;
      color: #6b7280;
      margin-bottom: 0.5rem;
    }

    #map {
      width: 100%;
      height: 380px;
      border-radius: 1rem;
      overflow: hidden;
      border: 1px solid #d1d5db;
      margin-bottom: 1.75rem;
    }

    .section {
      margin-top: 1rem;
    }

    .section p {
      font-size: 0.9rem;
      line-height: 1.45;
      color: #4b5563;
    }

    .section strong {
      color: #111827;
    }

    .resultado-ok {
      color: #059669;
      font-weight: 600;
    }

    .resultado-nok {
      color: #b91c1c;
      font-weight: 600;
    }

    ul.coincidencias {
      margin-top: 0.35rem;
      margin-left: 1rem;
      font-size: 0.9rem;
      color: #374151;
    }

    ul.coincidencias li {
      margin-bottom: 0.15rem;
    }

    /* Tabla de atributos */
    #detalle-atributos-prc {
      margin-top: 0.75rem;
    }

    .atributos-item h4 {
      font-size: 0.98rem;
      margin-bottom: 0.4rem;
      color: #111827;
    }

    table.tabla-atributos {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    table.tabla-atributos th,
    table.tabla-atributos td {
      border: 1px solid #e5e7eb;
      padding: 0.35rem 0.55rem;
      text-align: left;
      vertical-align: top;
    }

    table.tabla-atributos th {
      width: 28%;
      background: #f3f4f6;
      font-weight: 600;
      color: #374151;
    }

    table.tabla-atributos tr:nth-child(even) td {
      background: #f9fafb;
    }

    /* Botones de acción */
    .actions-row {
      margin-top: 2rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    button.action-button {
      border: none;
      border-radius: 999px;
      padding: 0.7rem 1.5rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      background: #020617;
      color: #f9fafb;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
    }

    button.action-button:hover {
      opacity: 0.94;
      transform: translateY(-0.5px);
    }

    button.action-button:active {
      transform: translateY(0);
      opacity: 0.88;
    }

    button.action-button svg {
      width: 16px;
      height: 16px;
    }
  </style>
</head>
<body>
  <div class="page">
    <div id="report-wrapper">
      <header>
        <h1>GeoIPT - Reporte del punto consultado</h1>
        <div class="coords-row">
          <div class="coords-block">
            <strong>Coordenadas WGS84</strong>
            <span>Lat: <span id="lat-display">-</span></span>
            <span>Lon: <span id="lon-display">-</span></span>
          </div>
          <div class="coords-block">
            <strong>Coordenadas UTM 19S (EPSG:32719)</strong>
            <span>Este: <span id="utm-e-display">-</span></span>
            <span>Norte: <span id="utm-n-display">-</span></span>
          </div>
          <div class="coords-block">
            <strong>Región</strong>
            <span id="region-display">-</span>
          </div>
          <div class="coords-block">
            <strong>Instrumento(s) consultado(s)</strong>
            <span id="instrumento-display">-</span>
          </div>
        </div>
      </header>

      <section>
        <h2>Mapa de referencia</h2>
        <p class="tip">
          Tip: puedes hacer clic nuevamente en este mapa para abrir un nuevo reporte sobre un nuevo punto (se abrirá en una pestaña adicional).
        </p>
        <div id="map"></div>
      </section>

      <section class="section">
        <h2>Consulta PRC / SCC (punto sobre polígonos de toda la región)</h2>
        <p>
          Evaluación del punto sobre todos los polígonos de los instrumentos PRC/SCC. 
        </p>
        <div id="resultado-prc" style="margin-top:0.5rem; font-size:0.95rem;"></div>
        <ul id="lista-coincidencias" class="coincidencias"></ul>

        <h3 id="titulo-atributos" style="margin-top: 1.5rem;">
          Detalle de atributos del/los polígono(s)
        </h3>
        <p id="instrumento-atributos" class="tip"></p>
        <div id="detalle-atributos-prc"></div>
      </section>

      <div class="nota-origen-wrapper">
        <div class="nota-titulo" id="nota-toggle">
          <br>
          <span class="icono" id="nota-icono">+</span>
          Nota sobre el origen de la información
        </div>

        <div class="nota-contenido" id="nota-contenido">
          <p>
            Las capas utilizadas en este reporte corresponden a instrumentos de planificación territorial 
            publicados oficialmente por el Ministerio de Vivienda y Urbanismo (MINVU) y otros organismos del Estado de Chile.
            La información mostrada por el presente visor se basa en archivos en formato KML descargados desde la 
            Infraestructura de Datos Espaciales del MINVU (IDE MINVU).
          </p>

          <p>
            Los archivos oficiales, actualizados y disponibles para descarga pública, pueden ser revisados directamente en:
            <a href="https://ide.minvu.cl/pages/descargas" target="_blank" rel="noopener">
              https://ide.minvu.cl/pages/descargas
            </a>.
          </p>

          <p>
            Este reporte es referencial y no reemplaza certificaciones emitidas por organismos competentes.
          </p>
        </div>
      </div>

      <div class="actions-row">
        <button id="btn-descargar-kml" type="button" class="action-button">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M12 3v9m0 0 3-3m-3 3-3-3M5 18h14M6 21h12" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          Descargar KML
        </button>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Proj4 para coordenadas UTM -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.js" integrity="sha512-bVmL59OstkCfyhMDnwUdIBcyKyxM/oZhIu7lq+SIURMi5A+tg1mzRi51gfYWS+ytfV/6s5wx2cgHBw0tSmyYVQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- tokml para exportar GeoJSON a KML -->
  <script src="https://unpkg.com/tokml@0.4.0/tokml.js"></script>

  <script>
    function getParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    function escapeHtml(text) {
      if (text == null) return "";
      return String(text)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    // Extrae TODOS los atributos desde un Placemark KML
    function getAttributesFromPlacemark(placemarkEl) {
      const attrs = {};

      // ExtendedData/Data
      placemarkEl.querySelectorAll("ExtendedData Data").forEach((data) => {
        const name =
          data.getAttribute("name") ||
          (data.querySelector("displayName") &&
            data.querySelector("displayName").textContent.trim());
        const value =
          (data.querySelector("value") &&
            data.querySelector("value").textContent.trim()) ||
          "";
        if (name) attrs[name] = value;
      });

      // ExtendedData/SimpleData
      placemarkEl.querySelectorAll("ExtendedData SimpleData").forEach((sd) => {
        const name = sd.getAttribute("name");
        const value = sd.textContent.trim();
        if (name) attrs[name] = value;
      });

      // name del Placemark
      const nameEl = placemarkEl.querySelector("name");
      if (nameEl) {
        const val = nameEl.textContent.trim();
        if (val && !attrs["NAME"]) {
          attrs["NAME"] = val;
        }
      }

      // description del Placemark (sin HTML)
      const descEl = placemarkEl.querySelector("description");
      if (descEl && descEl.textContent.trim()) {
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = descEl.textContent;
        const plainText = tempDiv.textContent || tempDiv.innerText || "";
        if (plainText.trim()) {
          attrs["DESCRIPTION"] = plainText.trim();
        }
      }

      return attrs;
    }

    function renderAttributesTable(placemarkEl, index) {
      const attrs = getAttributesFromPlacemark(placemarkEl);
      const keys = Object.keys(attrs);

      const zonaLabel = attrs["ZONA"]
        ? `Zona : ${escapeHtml(attrs["ZONA"])}`
        : `Polígono ${index + 1}`;

      if (!keys.length) {
        return `
          <div class="atributos-item">
            <h4>${zonaLabel}</h4>
            <p>No se encontraron atributos en el KML para este polígono.</p>
          </div>
        `;
      }

      const rows = keys
        .map(
          (key) => `
          <tr>
            <th>${escapeHtml(key)}</th>
            <td>${escapeHtml(attrs[key])}</td>
          </tr>
        `
        )
        .join("");

      return `
        <div class="atributos-item" style="margin-top: 1rem;">
          <h4>${zonaLabel}</h4>
          <table class="tabla-atributos">
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>
      `;
    }

    function actualizarAtributosPRC(matchingPlacemarks) {
      const container = document.getElementById("detalle-atributos-prc");
      if (!container) return;

      if (!matchingPlacemarks || !matchingPlacemarks.length) {
        container.innerHTML =
          "<p>No hay atributos que mostrar porque el punto no se encontró dentro de ningún polígono.</p>";
        return;
      }

      container.innerHTML = matchingPlacemarks
        .map((plc, idx) => renderAttributesTable(plc, idx))
        .join("");
    }

    // Conversión WGS84 -> UTM 19S (EPSG:32719) usando proj4
    function actualizarUTM(lat, lon) {
      try {
        if (!proj4.defs["EPSG:32719"]) {
          proj4.defs(
            "EPSG:32719",
            "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs"
          );
        }
        const utm = proj4("EPSG:4326", "EPSG:32719", [lon, lat]);
        document.getElementById("utm-e-display").textContent = utm[0]
          .toFixed(3)
          .replace(".", ",");
        document.getElementById("utm-n-display").textContent = utm[1]
          .toFixed(3)
          .replace(".", ",");
      } catch (e) {
        console.error("Error UTM:", e);
      }
    }

    // Punto en polígono (Ray casting)
    function pointInPolygon(lat, lon, polygonLatLngs) {
      let inside = false;
      const x = lon;
      const y = lat;

      for (let i = 0, j = polygonLatLngs.length - 1; i < polygonLatLngs.length; j = i++) {
        const xi = polygonLatLngs[i].lng,
          yi = polygonLatLngs[i].lat;
        const xj = polygonLatLngs[j].lng,
          yj = polygonLatLngs[j].lat;

        const intersect =
          yi > y !== yj > y &&
          x < ((xj - xi) * (y - yi)) / (yj - yi + 1e-12) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function parseKmlPolygons(kmlText) {
      const parser = new DOMParser();
      const xml = parser.parseFromString(kmlText, "application/xml");
      const placemarks = Array.from(xml.getElementsByTagName("Placemark"));
      const results = [];

      placemarks.forEach((pm) => {
        const polygons = [];

        pm.querySelectorAll("Polygon").forEach((poly) => {
          const coordsEl = poly.querySelector("outerBoundaryIs coordinates, outerBoundaryIs>LinearRing>coordinates, coordinates");
          if (!coordsEl) return;
          const coordsText = coordsEl.textContent.trim();
          if (!coordsText) return;

          const coords = coordsText
            .split(/\s+/)
            .map((pair) => {
              const parts = pair.split(",");
              const lon = parseFloat(parts[0]);
              const lat = parseFloat(parts[1]);
              if (isNaN(lat) || isNaN(lon)) return null;
              return L.latLng(lat, lon);
            })
            .filter(Boolean);

          if (coords.length >= 3) {
            polygons.push(coords);
          }
        });

        pm.querySelectorAll("MultiGeometry Polygon").forEach((poly) => {
          const coordsEl = poly.querySelector("outerBoundaryIs coordinates, outerBoundaryIs>LinearRing>coordinates, coordinates");
          if (!coordsEl) return;
          const coordsText = coordsEl.textContent.trim();
          if (!coordsText) return;

          const coords = coordsText
            .split(/\s+/)
            .map((pair) => {
              const parts = pair.split(",");
              const lon = parseFloat(parts[0]);
              const lat = parseFloat(parts[1]);
              if (isNaN(lat) || isNaN(lon)) return null;
              return L.latLng(lat, lon);
            })
            .filter(Boolean);

          if (coords.length >= 3) {
            polygons.push(coords);
          }
        });

        if (polygons.length) {
          results.push({
            placemarkEl: pm,
            polygons,
          });
        }
      });

      return results;
    }

    async function evaluarPRC(lat, lon, regionCode) {
      const resultadoDiv = document.getElementById("resultado-prc");
      const listaUl = document.getElementById("lista-coincidencias");

      resultadoDiv.textContent = "Evaluando polígonos PRC/SCC de la región...";
      listaUl.innerHTML = "";

      const matchingPlacemarks = [];
      const coincidenciasArchivos = new Map();

      const basePath = `capas/capas_${regionCode}/`;
      const listadoUrl = `${basePath}listado.json`;

      // limpiar capa de resultado si existe
      if (window._geoiptResultado) {
        window._geoiptResultado.clearLayers();
      }

      try {
        const listadoResp = await fetch(listadoUrl);
        if (!listadoResp.ok) {
          throw new Error("No se pudo leer listado.json de la región " + regionCode);
        }
        const listado = await listadoResp.json();

        let archivos = [];
        if (Array.isArray(listado)) {
          archivos = listado;
        } else if (Array.isArray(listado.kml)) {
          archivos = listado.kml;
        }

        for (const entry of archivos) {
          let archivo = "";
          let nombreInstrumento = "";

          if (typeof entry === "string") {
            archivo = entry;
            nombreInstrumento = entry;
          } else if (entry && typeof entry === "object") {
            archivo =
              entry.archivo || entry.kml || entry.nombre || "";
            nombreInstrumento =
              entry.nombre || archivo;
          }

          if (!archivo) continue;

          const kmlUrl = basePath + archivo;

          try {
            const kmlResp = await fetch(kmlUrl);
            if (!kmlResp.ok) {
              console.warn("No se pudo leer KML:", kmlUrl);
              continue;
            }
            const kmlText = await kmlResp.text();
            const features = parseKmlPolygons(kmlText);

            features.forEach((feat) => {
              let contiene = false;

              // atributos del Placemark original
              const attrs = getAttributesFromPlacemark(feat.placemarkEl) || {};

              // nombre amigable opcional
              if (!attrs.name) {
                if (attrs.ZONA) {
                  attrs.name = attrs.ZONA;
                } else if (attrs.NOMBRE) {
                  attrs.name = attrs.NOMBRE;
                }
              }

              feat.polygons.forEach((polyCoords) => {
                if (pointInPolygon(lat, lon, polyCoords)) {
                  contiene = true;

                  const polyLayer = L.polygon(polyCoords, {
                    color: "#2563eb",
                    weight: 2,
                    fillColor: "#3b82f6",
                    fillOpacity: 0.15,
                  });

                  // adjuntamos atributos para que viajen al KML
                  polyLayer.feature = {
                    type: "Feature",
                    properties: attrs,
                  };

                  if (window._geoiptResultado) {
                    polyLayer.addTo(window._geoiptResultado);
                  } else {
                    polyLayer.addTo(window._geoiptMap);
                  }
                }
              });

              if (contiene) {
                matchingPlacemarks.push(feat.placemarkEl);

                if (!coincidenciasArchivos.has(archivo)) {
                  coincidenciasArchivos.set(archivo, {
                    archivo,
                    nombreInstrumento,
                  });
                }
              }
            });
          } catch (errKml) {
            console.warn("Error procesando KML", kmlUrl, errKml);
          }
        }

        if (matchingPlacemarks.length > 0) {
          resultadoDiv.innerHTML =
            '<span class="resultado-ok">Resultado:</span> El punto consultado se encuentra dentro de uno o más polígonos de los instrumentos PRC/SCC de la región.';
          listaUl.innerHTML = "";

          coincidenciasArchivos.forEach((obj) => {
            const li = document.createElement("li");
            li.textContent = `Coincidencia en archivo: ${obj.archivo}`;
            listaUl.appendChild(li);
          });

          actualizarAtributosPRC(matchingPlacemarks);

          // Instrumentos consultados detectados por el motor
          const instrumentos = Array.from(coincidenciasArchivos.values())
            .map((obj) => obj.archivo.replace(/\.kml$/i, ""))
            .join(", ");

          if (instrumentos) {
            const instrumentoDisplay = document.getElementById("instrumento-display");
            if (instrumentoDisplay) {
              instrumentoDisplay.textContent = instrumentos;
            }

            const tituloAttr = document.getElementById("titulo-atributos");
            if (tituloAttr) {
              tituloAttr.textContent =
                "Detalle de atributos del/los polígono(s) – " + instrumentos;
            }

            const pInstrumentoAttr = document.getElementById("instrumento-atributos");
            if (pInstrumentoAttr) {
              pInstrumentoAttr.textContent =
                "Instrumento(s) consultado(s): " + instrumentos;
            }
          }
        } else {
          resultadoDiv.innerHTML =
            '<span class="resultado-nok">Resultado:</span> El punto consultado no se encuentra dentro de ningún polígono de los archivos PRC/SCC cargados.';
          listaUl.innerHTML = "";
          actualizarAtributosPRC([]);

          // Reset encabezados cuando no hay match
          const instrumentoDisplay = document.getElementById("instrumento-display");
          if (instrumentoDisplay) {
            instrumentoDisplay.textContent = "-";
          }
          const tituloAttr = document.getElementById("titulo-atributos");
          if (tituloAttr) {
            tituloAttr.textContent = "Detalle de atributos del/los polígono(s)";
          }
          const pInstrumentoAttr = document.getElementById("instrumento-atributos");
          if (pInstrumentoAttr) {
            pInstrumentoAttr.textContent =
              "No se encontró ningún instrumento que contenga el punto consultado.";
          }
        }
      } catch (err) {
        console.error(err);
        resultadoDiv.innerHTML =
          '<span class="resultado-nok">Resultado:</span> No fue posible evaluar los polígonos PRC/SCC de la región (revisa listado.json y la ruta de los KML).';
        listaUl.innerHTML = "";
        actualizarAtributosPRC([]);

        const instrumentoDisplay = document.getElementById("instrumento-display");
        if (instrumentoDisplay) {
          instrumentoDisplay.textContent = "-";
        }
      }
    }

    function initMap(lat, lon) {
      const map = L.map("map").setView([lat, lon], 15);
      window._geoiptMap = map;

      const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors',
      }).addTo(map);

      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution: "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, and the GIS User Community",
        }
      );

      L.control.layers(
        { "Mapa calle": osm, Satélite: esriSat },
        {},
        { position: "topright" }
      ).addTo(map);

      // capa vacía donde se almacenan los polígonos que hicieron match
      window._geoiptResultado = L.featureGroup().addTo(map);

      const marker = L.marker([lat, lon]).addTo(map);
      marker.bindPopup(
        `Punto consultado<br>Lat: ${lat.toFixed(6)}<br>Lon: ${lon.toFixed(6)}`
      ).openPopup();

      // Al hacer clic en el mapa, abrir nueva pestaña con nuevo punto
      map.on("click", (e) => {
        const url = new URL(window.location.href);
        url.searchParams.set("lat", e.latlng.lat.toString());
        url.searchParams.set("lon", e.latlng.lng.toString());
        window.open(url.toString(), "_blank");
      });
    }

    function initKmlButton() {
      const btn = document.getElementById("btn-descargar-kml");
      if (!btn) return;

      btn.addEventListener("click", () => {
        const group = window._geoiptResultado;
        if (!group || group.getLayers().length === 0) {
          alert("No hay ningún polígono para descargar.");
          return;
        }

        // GeoJSON desde la capa de resultado
        const gj = group.toGeoJSON();

        // Nombre del instrumento (solo para metadata interna del KML)
        let instrumentoRaw =
          (document.getElementById("instrumento-display")?.textContent || "PRC")
            .split(",")[0]
            .trim();

        let instrumento = instrumentoRaw
          .replace(/^IPT_\d+_/i, "")
          .replace(/_/g, " ");

        // Zonas involucradas (para el nombre del Document)
        let zonas = [];
        gj.features.forEach((f) => {
          if (f.properties && f.properties.ZONA) {
            const z = String(f.properties.ZONA).trim().split(/\s+/)[0];
            zonas.push(z);
          }
        });
        zonas = [...new Set(zonas)];
        const nombreZona = zonas.length ? zonas.join("_") : "Zona";

        // Timestamp AAAAMMDD_HHMMSS
        function timestamp() {
          const now = new Date();
          const YYYY = now.getFullYear();
          const MM = String(now.getMonth() + 1).padStart(2, "0");
          const DD = String(now.getDate()).padStart(2, "0");
          const hh = String(now.getHours()).padStart(2, "0");
          const mm = String(now.getMinutes()).padStart(2, "0");
          const ss = String(now.getSeconds()).padStart(2, "0");
          return `${YYYY}${MM}${DD}_${hh}${mm}${ss}`;
        }

        const nombreArchivo = `descargaKML_${timestamp()}.kml`;

        // Convertir GeoJSON a KML
        let kmlString = tokml(gj, {
          documentName: instrumento,
          name: nombreZona
        });

        // Agregar estilo azul semitransparente
        const styleBlock = `
  <Style id="geoipt_poly">
    <LineStyle>
      <color>ffeb6325</color>
      <width>2</width>
    </LineStyle>
    <PolyStyle>
      <color>66f6823b</color>
    </PolyStyle>
  </Style>`;

        kmlString = kmlString.replace("<Document>", "<Document>" + styleBlock);
        kmlString = kmlString.replace(
          /<Placemark>/g,
          "<Placemark><styleUrl>#geoipt_poly</styleUrl>"
        );

        const blob = new Blob([kmlString], {
          type: "application/vnd.google-earth.kml+xml;charset=utf-8"
        });

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = nombreArchivo;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }

    document.addEventListener("DOMContentLoaded", () => {
      const latParam = parseFloat(getParam("lat") || "-27.0");
      const lonParam = parseFloat(getParam("lon") || "-70.0");
      const regionCode = getParam("region") || "--";

      document.getElementById("lat-display").textContent = latParam.toFixed(6);
      document.getElementById("lon-display").textContent = lonParam.toFixed(6);
      document.getElementById("region-display").textContent = regionCode;

      actualizarUTM(latParam, lonParam);
      initMap(latParam, lonParam);
      initKmlButton();

      if (regionCode && regionCode !== "--") {
        evaluarPRC(latParam, lonParam, regionCode);
      } else {
        document.getElementById("resultado-prc").innerHTML =
          '<span class="resultado-nok">Resultado:</span> No se indicó código de región en la URL.';
      }
    });
  </script>
</body>
</html>

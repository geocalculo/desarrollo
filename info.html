<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>GeoIPT - Reporte del punto consultado</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin
  />

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, Helvetica, Arial, sans-serif;
      background: #e5e7eb;
      color: #0f172a;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem 0.5rem;
    }

    .page {
      width: 100%;
      max-width: 1000px;
    }

    #report-wrapper {
      background: #f9fafb;
      border-radius: 1.5rem;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.18);
      padding: 2rem 2.5rem;
    }

    @media (max-width: 640px) {
      #report-wrapper {
        padding: 1.5rem 1.25rem;
        border-radius: 0.75rem;
      }
    }

    h1 {
      font-size: 1.6rem;
      margin-bottom: 0.75rem;
    }

    .coords-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      font-size: 0.9rem;
      color: #4b5563;
      margin-bottom: 1.5rem;
    }

    .coords-block strong {
      display: block;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #6b7280;
      margin-bottom: 0.25rem;
    }

    .coords-block span {
      display: inline-block;
      margin-right: 0.35rem;
    }

    h2 {
      font-size: 1.1rem;
      margin: 1.25rem 0 0.35rem;
    }

    .tip {
      font-size: 0.75rem;
      color: #6b7280;
      margin-bottom: 0.5rem;
    }

    #map {
      width: 100%;
      height: 380px;
      border-radius: 1rem;
      overflow: hidden;
      border: 1px solid #d1d5db;
      margin-bottom: 1.75rem;
    }

    .section {
      margin-top: 1rem;
    }

    .section p {
      font-size: 0.9rem;
      line-height: 1.45;
      color: #4b5563;
    }

    .section strong {
      color: #111827;
    }

    .resultado-ok {
      color: #059669;
      font-weight: 600;
    }

    .resultado-nok {
      color: #b91c1c;
      font-weight: 600;
    }

    ul.coincidencias {
      margin-top: 0.35rem;
      margin-left: 1rem;
      font-size: 0.9rem;
      color: #374151;
    }

    ul.coincidencias li {
      margin-bottom: 0.15rem;
    }

    /* Tabla de atributos */
    #detalle-atributos-prc {
      margin-top: 0.75rem;
    }

    .atributos-item h4 {
      font-size: 0.98rem;
      margin-bottom: 0.4rem;
      color: #111827;
    }

    table.tabla-atributos {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    table.tabla-atributos th,
    table.tabla-atributos td {
      border: 1px solid #e5e7eb;
      padding: 0.35rem 0.55rem;
      text-align: left;
      vertical-align: top;
    }

    table.tabla-atributos th {
      width: 28%;
      background: #f3f4f6;
      font-weight: 600;
      color: #374151;
    }

    table.tabla-atributos tr:nth-child(even) td {
      background: #f9fafb;
    }

    /* Barra superior y botón Home */
    .top-bar {
      display: flex;
      justify-content: flex-start;
      margin-bottom: 1rem;
    }

    .home-button {
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.2rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      background: #e5e7eb;
      color: #111827;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.12);
    }

    .home-button:hover {
      background: #d1d5db;
    }

    .home-button svg {
      width: 16px;
      height: 16px;
    }

    /* Botones de acción */
    .actions-row {
      margin-top: 2rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    button.action-button {
      border: none;
      border-radius: 999px;
      padding: 0.7rem 1.5rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      background: #020617;
      color: #f9fafb;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
    }

    button.action-button:hover {
      opacity: 0.94;
      transform: translateY(-0.5px);
    }

    button.action-button:active {
      transform: translateY(0);
      opacity: 0.88;
    }

    button.action-button svg {
      width: 16px;
      height: 16px;
    }

    .nota-origen-wrapper {
      margin-top: 1.5rem;
      font-size: 0.85rem;
      color: #4b5563;
    }

    .nota-titulo {
      cursor: pointer;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .nota-titulo .icono {
      display: inline-flex;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid #9ca3af;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      color: #4b5563;
    }

    .nota-contenido {
      margin-top: 0.5rem;
      display: none;
    }

    .nota-contenido p {
      margin-bottom: 0.35rem;
      line-height: 1.4;
    }

    /* Overlay de carga */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .loading-spinner {
      width: 48px;
      height: 48px;
      border-radius: 999px;
      border: 4px solid #e5e7eb;
      border-top-color: #38bdf8;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Ocultar elementos en impresión */
    .no-print {
      /* se ocultan en @media print */
    }

    @media print {
      body {
        background: #ffffff;
        padding: 0;
      }

      #report-wrapper {
        box-shadow: none;
        border-radius: 0;
      }

      .no-print {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <div id="loading-overlay" class="loading-overlay">
    <div class="loading-spinner" aria-label="Cargando reporte..."></div>
  </div>

  <div class="page">
    <div id="report-wrapper">
      <!-- Botón Home (solo pantalla) -->
      <div class="top-bar no-print">
        <button id="btn-home" type="button" class="home-button">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path
              d="M4 11L12 4l8 7v8a1 1 0 0 1-1 1h-4v-5H9v5H5a1 1 0 0 1-1-1v-8Z"
              stroke="currentColor"
              stroke-width="1.7"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          Home
        </button>
      </div>

      <header>
        <h1>GeoIPT - Reporte del punto consultado</h1>
        <div class="coords-row">
          <div class="coords-block">
            <strong>Coordenadas WGS84</strong>
            <span>Lat: <span id="lat-display">-</span></span>
            <span>Lon: <span id="lon-display">-</span></span>
          </div>
          <div class="coords-block">
            <strong>Coordenadas UTM 19S (EPSG:32719)</strong>
            <span>Este: <span id="utm-e-display">-</span></span>
            <span>Norte: <span id="utm-n-display">-</span></span>
          </div>
          <div class="coords-block">
            <strong>Región</strong>
            <span id="region-display">-</span>
          </div>
          <div class="coords-block">
            <strong>Instrumento(s) consultado(s)</strong>
            <span id="instrumento-display">-</span>
          </div>
        </div>
      </header>

      <section>
        <h2>Mapa de referencia</h2>
        <p class="tip">
          Tip: puedes hacer clic nuevamente en este mapa para abrir un nuevo reporte sobre un nuevo punto (se abrirá en una pestaña adicional).
        </p>

        <!-- contenedor para mapa + mira de rifle -->
        <div style="position: relative;">
          <div id="map"></div>

          <!-- Mira de rifle (solo pantalla) -->
          <button
            id="btn-geolocate"
            type="button"
            class="no-print"
            aria-label="Ubicar mi posición"
            title="Ubicar mi posición"
            style="
              position:absolute;
              right:16px;
              bottom:16px;
              width:44px;
              height:44px;
              border-radius:999px;
              border:1px solid #d1d5db;
              background:#ffffffdd;
              display:flex;
              align-items:center;
              justify-content:center;
              box-shadow:0 1px 3px rgba(15,23,42,0.25);
              cursor:pointer;
            "
          >
            <svg
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="#111827"
              stroke-width="1.8"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <circle cx="12" cy="12" r="3"></circle>
              <line x1="12" y1="2" x2="12" y2="5"></line>
              <line x1="12" y1="19" x2="12" y2="22"></line>
              <line x1="2" y1="12" x2="5" y2="12"></line>
              <line x1="19" y1="12" x2="22" y2="12"></line>
            </svg>
          </button>
        </div>
      </section>

      <section class="section">
        <h2>Consulta PRC / SCC (punto sobre polígonos de toda la región)</h2>
        <p>
          Evaluación del punto sobre todos los polígonos de los instrumentos PRC/SCC de la región seleccionada.
          El combo del mapa principal se usa solo para zoom óptico; aquí se revisan
          <strong>todos los KML declarados en el listado.json de la región</strong>, filtrando previamente solo
          aquellos cuya extensión intersecta el área visible del mapa de referencia.
        </p>
        <div id="resultado-prc" style="margin-top:0.5rem; font-size:0.95rem;"></div>
        <ul id="lista-coincidencias" class="coincidencias"></ul>

        <h3 id="titulo-atributos" style="margin-top: 1.5rem;">
          Detalle de atributos del/los polígono(s)
        </h3>
        <p id="instrumento-atributos" class="tip"></p>
        <div id="detalle-atributos-prc"></div>
      </section>

      <div class="nota-origen-wrapper">
        <div class="nota-titulo" id="nota-toggle">
          <br />
          <span class="icono" id="nota-icono">+</span>
          Nota sobre el origen de la información
        </div>

        <div class="nota-contenido" id="nota-contenido">
          <p>
            Las capas utilizadas en este reporte corresponden a instrumentos de planificación territorial
            publicados oficialmente por el Ministerio de Vivienda y Urbanismo (MINVU) y otros organismos del Estado de Chile.
            La información mostrada por el presente visor se basa en archivos en formato KML descargados desde la
            Infraestructura de Datos Espaciales del MINVU (IDE MINVU).
          </p>

          <p>
            Los archivos oficiales, actualizados y disponibles para descarga pública, pueden ser revisados directamente en:
            <a href="https://ide.minvu.cl/pages/descargas" target="_blank" rel="noopener">
              https://ide.minvu.cl/pages/descargas
            </a>.
          </p>

          <p>
            Este reporte es referencial y no reemplaza certificaciones emitidas por organismos competentes.
          </p>
        </div>
      </div>

      <div class="actions-row no-print">
        <button id="btn-descargar-kml" type="button" class="action-button">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path
              d="M12 3v9m0 0 3-3m-3 3-3-3M5 18h14M6 21h12"
              stroke="currentColor"
              stroke-width="1.7"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          Descargar KML
        </button>

        <button id="btn-print" type="button" class="action-button">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path
              d="M7 9V4h10v5M6 18H5a2 2 0 0 1-2-2v-4a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-1M8 18h8v3H8v-3Z"
              stroke="currentColor"
              stroke-width="1.7"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          Imprimir reporte
        </button>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin
  ></script>

  <script src="js/utm.js"></script>

  <!-- tokml para exportar GeoJSON a KML -->
  <script src="https://unpkg.com/tokml@0.4.0/tokml.js"></script>

  <script>
    const loadingOverlay = document.getElementById("loading-overlay");

    function showLoading() {
      if (loadingOverlay) loadingOverlay.style.display = "flex";
    }

    function hideLoading() {
      if (loadingOverlay) loadingOverlay.style.display = "none";
    }

    function getParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    function escapeHtml(text) {
      if (text == null) return "";
      return String(text)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    // Extrae TODOS los atributos desde un Placemark KML
    function getAttributesFromPlacemark(placemarkEl) {
      const attrs = {};

      // ExtendedData/Data
      placemarkEl.querySelectorAll("ExtendedData Data").forEach((data) => {
        const name =
          data.getAttribute("name") ||
          (data.querySelector("displayName") &&
            data.querySelector("displayName").textContent.trim());
        const value =
          (data.querySelector("value") &&
            data.querySelector("value").textContent.trim()) ||
          "";
        if (name) attrs[name] = value;
      });

      // ExtendedData/SimpleData
      placemarkEl.querySelectorAll("ExtendedData SimpleData").forEach((sd) => {
        const name = sd.getAttribute("name");
        const value = sd.textContent.trim();
        if (name) attrs[name] = value;
      });

      // name del Placemark
      const nameEl = placemarkEl.querySelector("name");
      if (nameEl) {
        const val = nameEl.textContent.trim();
        if (val && !attrs["NAME"]) {
          attrs["NAME"] = val;
        }
      }

      // description del Placemark (sin HTML)
      const descEl = placemarkEl.querySelector("description");
      if (descEl && descEl.textContent.trim()) {
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = descEl.textContent;
        const plainText = tempDiv.textContent || tempDiv.innerText || "";
        if (plainText.trim()) {
          attrs["DESCRIPTION"] = plainText.trim();
        }
      }

      return attrs;
    }

    function renderAttributesTable(placemarkEl, index) {
      const attrs = getAttributesFromPlacemark(placemarkEl);
      const keys = Object.keys(attrs);

      const zonaLabel = attrs["ZONA"]
        ? `Zona : ${escapeHtml(attrs["ZONA"])}`
        : `Polígono ${index + 1}`;

      if (!keys.length) {
        return `
          <div class="atributos-item">
            <h4>${zonaLabel}</h4>
            <p>No se encontraron atributos en el KML para este polígono.</p>
          </div>
        `;
      }

      const rows = keys
        .map(
          (key) => `
          <tr>
            <th>${escapeHtml(key)}</th>
            <td>${escapeHtml(attrs[key])}</td>
          </tr>
        `
        )
        .join("");

      return `
        <div class="atributos-item" style="margin-top: 1rem;">
          <h4>${zonaLabel}</h4>
          <table class="tabla-atributos">
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>
      `;
    }

    function actualizarAtributosPRC(matchingPlacemarks) {
      const container = document.getElementById("detalle-atributos-prc");
      if (!container) return;

      if (!matchingPlacemarks || !matchingPlacemarks.length) {
        container.innerHTML =
          "<p>No hay atributos que mostrar porque el punto no se encontró dentro de ningún polígono.</p>";
        return;
      }

      container.innerHTML = matchingPlacemarks
        .map((plc, idx) => renderAttributesTable(plc, idx))
        .join("");
    }

    // Punto en polígono (Ray casting)
    function pointInPolygon(lat, lon, polygonLatLngs) {
      let inside = false;
      const x = lon;
      const y = lat;

      for (let i = 0, j = polygonLatLngs.length - 1; i < polygonLatLngs.length; j = i++) {
        const xi = polygonLatLngs[i].lng,
          yi = polygonLatLngs[i].lat;
        const xj = polygonLatLngs[j].lng,
          yj = polygonLatLngs[j].lat;

        const intersect =
          yi > y !== yj > y &&
          x < ((xj - xi) * (y - yi)) / (yj - yi + 1e-12) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function parseKmlPolygons(kmlText) {
      const parser = new DOMParser();
      const xml = parser.parseFromString(kmlText, "application/xml");
      const placemarks = Array.from(xml.getElementsByTagName("Placemark"));
      const results = [];

      placemarks.forEach((pm) => {
        const polygons = [];

        pm.querySelectorAll("Polygon").forEach((poly) => {
          const coordsEl =
            poly.querySelector(
              "outerBoundaryIs coordinates, outerBoundaryIs>LinearRing>coordinates, coordinates"
            );
          if (!coordsEl) return;
          const coordsText = coordsEl.textContent.trim();
          if (!coordsText) return;

          const coords = coordsText
            .split(/\s+/)
            .map((pair) => {
              const parts = pair.split(",");
              const lon = parseFloat(parts[0]);
              const lat = parseFloat(parts[1]);
              if (isNaN(lat) || isNaN(lon)) return null;
              return L.latLng(lat, lon);
            })
            .filter(Boolean);

          if (coords.length >= 3) {
            polygons.push(coords);
          }
        });

        pm.querySelectorAll("MultiGeometry Polygon").forEach((poly) => {
          const coordsEl =
            poly.querySelector(
              "outerBoundaryIs coordinates, outerBoundaryIs>LinearRing>coordinates, coordinates"
            );
          if (!coordsEl) return;
          const coordsText = coordsEl.textContent.trim();
          if (!coordsText) return;

          const coords = coordsText
            .split(/\s+/)
            .map((pair) => {
              const parts = pair.split(",");
              const lon = parseFloat(parts[0]);
              const lat = parseFloat(parts[1]);
              if (isNaN(lat) || isNaN(lon)) return null;
              return L.latLng(lat, lon);
            })
            .filter(Boolean);

          if (coords.length >= 3) {
            polygons.push(coords);
          }
        });

        if (polygons.length) {
          results.push({
            placemarkEl: pm,
            polygons,
          });
        }
      });

      return results;
    }

    // BBOX del mapa (viewport)
    function getViewBBox() {
      const map = window._geoiptMap;
      if (!map) return null;
      const b = map.getBounds();
      return {
        minLat: b.getSouth(),
        maxLat: b.getNorth(),
        minLon: b.getWest(),
        maxLon: b.getEast(),
      };
    }

    // Leer bbox de una entrada de listado.json
    // Soporta:
    // - bbox: [minLat, minLon, maxLat, maxLon]
    // - extent: [minLat, minLon, maxLat, maxLon]
    // - minLat, maxLat, minLon, maxLon como campos separados
    function getEntryBBox(entry) {
      if (!entry || typeof entry !== "object") return null;

      let minLat, maxLat, minLon, maxLon;

      if (Array.isArray(entry.bbox) && entry.bbox.length === 4) {
        [minLat, minLon, maxLat, maxLon] = entry.bbox.map(Number);
      } else if (Array.isArray(entry.extent) && entry.extent.length === 4) {
        [minLat, minLon, maxLat, maxLon] = entry.extent.map(Number);
      } else if (
        typeof entry.minLat !== "undefined" &&
        typeof entry.maxLat !== "undefined" &&
        typeof entry.minLon !== "undefined" &&
        typeof entry.maxLon !== "undefined"
      ) {
        minLat = Number(entry.minLat);
        maxLat = Number(entry.maxLat);
        minLon = Number(entry.minLon);
        maxLon = Number(entry.maxLon);
      }

      if (
        [minLat, maxLat, minLon, maxLon].some(
          (v) => typeof v !== "number" || isNaN(v)
        )
      ) {
        return null;
      }

      return { minLat, maxLat, minLon, maxLon };
    }

    function bboxesIntersect(a, b) {
      if (!a || !b) return true;
      const noOverlap =
        b.minLat > a.maxLat ||
        b.maxLat < a.minLat ||
        b.minLon > a.maxLon ||
        b.maxLon < a.minLon;
      return !noOverlap;
    }

    // === NUEVO: obtener BBOX del propio KML (Opción 1) ===
    function getKmlBBoxFromText(kmlText) {
      if (!kmlText) return null;

      // Intentar primero con LatLonBox / north-south-east-west
      const northMatch = kmlText.match(/<north>\s*([-\d.]+)\s*<\/north>/i);
      const southMatch = kmlText.match(/<south>\s*([-\d.]+)\s*<\/south>/i);
      const eastMatch  = kmlText.match(/<east>\s*([-\d.]+)\s*<\/east>/i);
      const westMatch  = kmlText.match(/<west>\s*([-\d.]+)\s*<\/west>/i);

      if (northMatch && southMatch && eastMatch && westMatch) {
        const north = parseFloat(northMatch[1]);
        const south = parseFloat(southMatch[1]);
        const east  = parseFloat(eastMatch[1]);
        const west  = parseFloat(westMatch[1]);

        if (
          ![north, south, east, west].some(
            (v) => typeof v !== "number" || isNaN(v)
          )
        ) {
          return {
            minLat: Math.min(north, south),
            maxLat: Math.max(north, south),
            minLon: Math.min(east, west),
            maxLon: Math.max(east, west),
          };
        }
      }

      // Si no hay LatLonBox, barrer las coordinates
      const coordMatches = [...kmlText.matchAll(/<coordinates>([\s\S]*?)<\/coordinates>/gi)];
      let minLat = 90,
        maxLat = -90,
        minLon = 180,
        maxLon = -180;
      let found = false;

      coordMatches.forEach((m) => {
        const block = m[1].trim();
        if (!block) return;
        const pairs = block.split(/\s+/);
        pairs.forEach((pair) => {
          const parts = pair.split(",");
          if (parts.length < 2) return;
          const lon = parseFloat(parts[0]);
          const lat = parseFloat(parts[1]);
          if (isNaN(lat) || isNaN(lon)) return;
          found = true;
          if (lat < minLat) minLat = lat;
          if (lat > maxLat) maxLat = lat;
          if (lon < minLon) minLon = lon;
          if (lon > maxLon) maxLon = lon;
        });
      });

      if (!found) return null;

      return { minLat, maxLat, minLon, maxLon };
    }

    // ============================
    //   EVALUAR PRC / SCC
    // ============================
    async function evaluarPRC(lat, lon, regionCode) {
      const resultadoDiv = document.getElementById("resultado-prc");
      const listaUl = document.getElementById("lista-coincidencias");

      resultadoDiv.textContent = "Evaluando polígonos PRC/SCC de la región...";
      listaUl.innerHTML = "";

      const matchingPlacemarks = [];
      const coincidenciasArchivos = new Map();

      const basePath = `capas/capas_${regionCode}/`;
      const listadoUrl = `${basePath}listado.json`;

      // limpiar capa de resultado si existe
      if (window._geoiptResultado) {
        window._geoiptResultado.clearLayers();
      }

      const viewBBox = getViewBBox(); // BBOX del mapa visible

      try {
        const listadoResp = await fetch(listadoUrl);
        if (!listadoResp.ok) {
          throw new Error(
            "No se pudo leer listado.json de la región " + regionCode
          );
        }
        const listado = await listadoResp.json();

        let archivos = [];

        // Soportar 3 formatos:
        // 1) Array simple
        if (Array.isArray(listado)) {
          archivos = listado;
          // 2) { kml: [ ... ] }
        } else if (Array.isArray(listado.kml)) {
          archivos = listado.kml;
          // 3) { instrumentos: [ ... ] }
        } else if (Array.isArray(listado.instrumentos)) {
          archivos = listado.instrumentos;
        }

        for (const entry of archivos) {
          let archivo = "";
          let nombreInstrumento = "";
          let entryMeta = null;

          if (typeof entry === "string") {
            archivo = entry;
            nombreInstrumento = entry;
          } else if (entry && typeof entry === "object") {
            archivo = entry.archivo || entry.kml || entry.nombre || "";
            nombreInstrumento = entry.nombre || archivo;
            entryMeta = entry;
          }

          if (!archivo) continue;

          // Filtro rápido con BBOX del listado.json si existe
          const entryBBox = getEntryBBox(entryMeta);
          if (viewBBox && entryBBox && !bboxesIntersect(viewBBox, entryBBox)) {
            continue;
          }

          const kmlUrl = basePath + archivo;

          try {
            const kmlResp = await fetch(kmlUrl);
            if (!kmlResp.ok) {
              console.warn("No se pudo leer KML:", kmlUrl);
              continue;
            }
            const kmlText = await kmlResp.text();

            // === NUEVO: filtro Opción 1 con BBOX del KML ===
            const kmlBBox = getKmlBBoxFromText(kmlText);
            if (viewBBox && kmlBBox && !bboxesIntersect(viewBBox, kmlBBox)) {
              // Si el KML no intersecta el área visible → se omite
              continue;
            }

            const features = parseKmlPolygons(kmlText);

            features.forEach((feat) => {
              let contiene = false;

              // atributos del Placemark original
              const attrs = getAttributesFromPlacemark(feat.placemarkEl) || {};

              // nombre amigable opcional
              if (!attrs.name) {
                if (attrs.ZONA) {
                  attrs.name = attrs.ZONA;
                } else if (attrs.NOMBRE) {
                  attrs.name = attrs.NOMBRE;
                }
              }

              feat.polygons.forEach((polyCoords) => {
                if (pointInPolygon(lat, lon, polyCoords)) {
                  contiene = true;

                  const polyLayer = L.polygon(polyCoords, {
                    color: "#2563eb",
                    weight: 2,
                    fillColor: "#3b82f6",
                    fillOpacity: 0.15,
                  });

                  // adjuntamos atributos para que viajen al KML
                  polyLayer.feature = {
                    type: "Feature",
                    properties: attrs,
                  };

                  if (window._geoiptResultado) {
                    polyLayer.addTo(window._geoiptResultado);
                  } else {
                    polyLayer.addTo(window._geoiptMap);
                  }
                }
              });

              if (contiene) {
                matchingPlacemarks.push(feat.placemarkEl);

                if (!coincidenciasArchivos.has(archivo)) {
                  coincidenciasArchivos.set(archivo, {
                    archivo,
                    nombreInstrumento,
                  });
                }
              }
            });
          } catch (errKml) {
            console.warn("Error procesando KML", kmlUrl, errKml);
          }
        }

        if (matchingPlacemarks.length > 0) {
          resultadoDiv.innerHTML =
            '<span class="resultado-ok">Resultado:</span> El punto consultado se encuentra dentro de uno o más polígonos de los instrumentos PRC/SCC de la región.';
          listaUl.innerHTML = "";

          coincidenciasArchivos.forEach((obj) => {
            const li = document.createElement("li");
            li.textContent = `Coincidencia en archivo: ${obj.archivo}`;
            listaUl.appendChild(li);
          });

          actualizarAtributosPRC(matchingPlacemarks);

          // Instrumentos consultados detectados por el motor
          const instrumentos = Array.from(coincidenciasArchivos.values())
            .map((obj) =>
              (obj.nombreInstrumento || obj.archivo).replace(/\.kml$/i, "")
            )
            .join(", ");

          if (instrumentos) {
            const instrumentoDisplay =
              document.getElementById("instrumento-display");
            if (instrumentoDisplay) {
              instrumentoDisplay.textContent = instrumentos;
            }

            const tituloAttr = document.getElementById("titulo-atributos");
            if (tituloAttr) {
              tituloAttr.textContent =
                "Detalle de atributos del/los polígono(s) – " +
                instrumentos;
            }

            const pInstrumentoAttr =
              document.getElementById("instrumento-atributos");
            if (pInstrumentoAttr) {
              pInstrumentoAttr.textContent =
                "Instrumento(s) consultado(s): " + instrumentos;
            }
          }
        } else {
          resultadoDiv.innerHTML =
            '<span class="resultado-nok">Resultado:</span> El punto consultado no se encuentra dentro de ningún polígono de los archivos PRC/SCC cargados.';
          listaUl.innerHTML = "";
          actualizarAtributosPRC([]);

          // Reset encabezados cuando no hay match
          const instrumentoDisplay =
            document.getElementById("instrumento-display");
          if (instrumentoDisplay) {
            instrumentoDisplay.textContent = "-";
          }
          const tituloAttr = document.getElementById("titulo-atributos");
          if (tituloAttr) {
            tituloAttr.textContent =
              "Detalle de atributos del/los polígono(s)";
          }
          const pInstrumentoAttr =
            document.getElementById("instrumento-atributos");
          if (pInstrumentoAttr) {
            pInstrumentoAttr.textContent =
              "No se encontró ningún instrumento que contenga el punto consultado.";
          }
        }
      } catch (err) {
        console.error(err);
        resultadoDiv.innerHTML =
          '<span class="resultado-nok">Resultado:</span> No fue posible evaluar los polígonos PRC/SCC de la región (revisa listado.json y la ruta de los KML).';
        listaUl.innerHTML = "";
        actualizarAtributosPRC([]);

        const instrumentoDisplay =
          document.getElementById("instrumento-display");
        if (instrumentoDisplay) {
          instrumentoDisplay.textContent = "-";
        }
      }
    }

    function initMap(lat, lon) {
      const map = L.map("map").setView([lat, lon], 15);
      window._geoiptMap = map;

      const osm = L.tileLayer(
        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        {
          maxZoom: 19,
          attribution: "&copy; OpenStreetMap contributors",
        }
      ).addTo(map);

      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution:
            "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, and the GIS User Community",
        }
      );

      L.control
        .layers(
          { "Mapa calle": osm, Satélite: esriSat },
          {},
          { position: "topright" }
        )
        .addTo(map);

      // capa vacía donde se almacenan los polígonos que hicieron match
      window._geoiptResultado = L.featureGroup().addTo(map);

      const marker = L.marker([lat, lon]).addTo(map);
      marker
        .bindPopup(
          `Punto consultado<br>Lat: ${lat.toFixed(6)}<br>Lon: ${lon.toFixed(6)}`
        )
        .openPopup();

      // Al hacer clic en el mapa, abrir nueva pestaña con nuevo punto
      map.on("click", (e) => {
        const url = new URL(window.location.href);
        url.searchParams.set("lat", e.latlng.lat.toString());
        url.searchParams.set("lon", e.latlng.lng.toString());
        window.open(url.toString(), "_blank");
      });
    }

    function initKmlButton() {
      const btn = document.getElementById("btn-descargar-kml");
      if (!btn) return;

      btn.addEventListener("click", () => {
        const group = window._geoiptResultado;
        if (!group || group.getLayers().length === 0) {
          alert("No hay ningún polígono para descargar.");
          return;
        }

        // GeoJSON desde la capa de resultado
        const gj = group.toGeoJSON();

        // Nombre del instrumento (solo para metadata interna del KML)
        let instrumentoRaw =
          (
            document.getElementById("instrumento-display")?.textContent ||
            "PRC"
          )
            .split(",")[0]
            .trim();

        let instrumento = instrumentoRaw
          .replace(/^IPT_\d+_/i, "")
          .replace(/_/g, " ");

        // Zonas involucradas (para el nombre del Document)
        let zonas = [];
        gj.features.forEach((f) => {
          if (f.properties && f.properties.ZONA) {
            const z = String(f.properties.ZONA).trim().split(/\s+/)[0];
            zonas.push(z);
          }
        });
        zonas = [...new Set(zonas)];
        const nombreZona = zonas.length ? zonas.join("_") : "Zona";

        // Timestamp AAAAMMDD_HHMMSS
        function timestamp() {
          const now = new Date();
          const YYYY = now.getFullYear();
          const MM = String(now.getMonth() + 1).padStart(2, "0");
          const DD = String(now.getDate()).padStart(2, "0");
          const hh = String(now.getHours()).padStart(2, "0");
          const mm = String(now.getMinutes()).padStart(2, "0");
          const ss = String(now.getSeconds()).padStart(2, "0");
          return `${YYYY}${MM}${DD}_${hh}${mm}${ss}`;
        }

        const nombreArchivo = `descargaKML_${timestamp()}.kml`;

        // Convertir GeoJSON a KML
        let kmlString = tokml(gj, {
          documentName: instrumento,
          name: nombreZona,
        });

        // Agregar estilo azul semitransparente
        const styleBlock = `
  <Style id="geoipt_poly">
    <LineStyle>
      <color>ffeb6325</color>
      <width>2</width>
    </LineStyle>
    <PolyStyle>
      <color>66f6823b</color>
    </PolyStyle>
  </Style>`;

        kmlString = kmlString.replace("<Document>", "<Document>" + styleBlock);
        kmlString = kmlString.replace(
          /<Placemark>/g,
          "<Placemark><styleUrl>#geoipt_poly</styleUrl>"
        );

        const blob = new Blob([kmlString], {
          type: "application/vnd.google-earth.kml+xml;charset=utf-8",
        });

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = nombreArchivo;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }

    function initNotaToggle() {
      const toggle = document.getElementById("nota-toggle");
      const contenido = document.getElementById("nota-contenido");
      const icono = document.getElementById("nota-icono");
      if (!toggle || !contenido || !icono) return;

      toggle.addEventListener("click", () => {
        const visible = contenido.style.display === "block";
        contenido.style.display = visible ? "none" : "block";
        icono.textContent = visible ? "+" : "–";
      });
    }

    function initHomeButton() {
      const btnHome = document.getElementById("btn-home");
      if (!btnHome) return;
      btnHome.addEventListener("click", () => {
        window.location.href = "index.html";
      });
    }

    function initPrintButton() {
      const btnPrint = document.getElementById("btn-print");
      if (!btnPrint) return;
      btnPrint.addEventListener("click", () => {
        window.print();
      });
    }

    // Mira de rifle (geolocalización sin marcador)
    function initGeolocateButton() {
      const btnGeo = document.getElementById("btn-geolocate");
      if (!btnGeo) return;

      btnGeo.addEventListener("click", () => {
        if (!navigator.geolocation) {
          alert("La geolocalización no está disponible en este navegador.");
          return;
        }

        navigator.geolocation.getCurrentPosition(
          (pos) => {
            if (!window._geoiptMap) return;
            window._geoiptMap.flyTo(
              [pos.coords.latitude, pos.coords.longitude],
              16
            );
          },
          () => {
            alert("No se pudo obtener la ubicación del dispositivo.");
          },
          { enableHighAccuracy: true, timeout: 10000 }
        );
      });
    }

    async function cargarReporte() {
      try {
        const latParam = parseFloat(getParam("lat") || "-27.0");
        const lonParam = parseFloat(getParam("lon") || "-70.0");
        const regionCode = getParam("region") || "--";

        document.getElementById("lat-display").textContent =
          latParam.toFixed(6);
        document.getElementById("lon-display").textContent =
          lonParam.toFixed(6);
        document.getElementById("region-display").textContent = regionCode;

        actualizarUTM(latParam, lonParam);
        initMap(latParam, lonParam);
        initKmlButton();
        initNotaToggle();
        initHomeButton();
        initPrintButton();
        initGeolocateButton();

        if (regionCode && regionCode !== "--") {
          await evaluarPRC(latParam, lonParam, regionCode);
        } else {
          document.getElementById("resultado-prc").innerHTML =
            '<span class="resultado-nok">Resultado:</span> No se indicó código de región en la URL.';
        }
      } catch (error) {
        console.error("Error al cargar el reporte:", error);
        alert("Ocurrió un problema al generar el reporte. Intenta nuevamente.");
      } finally {
        hideLoading();
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      showLoading();
      cargarReporte();
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>GeoIPT - Reporte del punto consultado</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, Helvetica, Arial, sans-serif;
      background: #0b1120;
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 8px;
    }

    header {
      max-width: 1200px;
      margin: 0 auto 8px auto;
      padding: 8px 12px;
      border-radius: 0.75rem;
      background: #020617;
      border: 1px solid #111827;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .title-block h1 {
      font-size: 1rem;
      font-weight: 600;
    }

    .title-block span {
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .coords-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.78rem;
    }

    .coords-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 999px;
      background: #111827;
      font-size: 0.72rem;
      color: #9ca3af;
    }

    main {
      flex: 1;
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(260px, 0.9fr);
      gap: 8px;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
      }
    }

    #map {
      width: 100%;
      min-height: 320px;
      height: calc(100vh - 180px);
      background: #020617;
      border-radius: 0.75rem;
      border: 1px solid #111827;
      overflow: hidden;
    }

    .panel-right {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .card {
      background: #020617;
      border-radius: 0.75rem;
      border: 1px solid #111827;
      padding: 10px 12px;
    }

    .card h2 {
      font-size: 0.9rem;
      margin-bottom: 4px;
    }

    .small {
      font-size: 0.78rem;
      color: #9ca3af;
    }

    .pill {
      display: inline-flex;
      padding: 2px 8px;
      border-radius: 999px;
      background: #111827;
      font-size: 0.74rem;
      margin-right: 4px;
      margin-bottom: 4px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 4px;
      font-size: 0.78rem;
    }

    th,
    td {
      border: 1px solid #1f2937;
      padding: 4px 6px;
      text-align: left;
    }

    th {
      background: #020617;
      font-weight: 500;
    }

    .no-match {
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .footer {
      max-width: 1200px;
      margin: 6px auto 0 auto;
      font-size: 0.7rem;
      color: #6b7280;
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
  </style>
</head>
<body>
  <header>
    <div class="title-block">
      <h1>GeoIPT · Reporte del punto consultado</h1>
      <span>Intersección con Instrumentos de Planificación Territorial (IPT)</span>
    </div>
    <div class="coords-block">
      <div class="coords-row">
        <span class="badge">Lat: <span id="lat-display">-</span></span>
        <span class="badge">Lon: <span id="lon-display">-</span></span>
        <span class="badge">Región: <span id="region-display">--</span></span>
      </div>
      <div class="small">
        El sistema recorre todos los KML declarados en
        <code>capas/capas_[REGIÓN]/listado.json</code> y detecta los polígonos
        que contienen el punto consultado.
      </div>
    </div>
  </header>

  <main>
    <section id="map"></section>

    <section class="panel-right">
      <div class="card">
        <h2>Instrumento(s) consultado(s)</h2>
        <div id="instrumentos-resumen" class="small">
          Procesando consulta…
        </div>
      </div>

      <div class="card">
        <h2>Detalle de atributos del/los polígono(s)</h2>
        <div id="detalle-atributos" class="small">
          A la espera de resultados de la consulta.
        </div>
      </div>
    </section>
  </main>

  <div class="footer">
    <div>GeoIPT · Desarrollo</div>
    <div>Consulta generada en tiempo real desde KML locales</div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Turf para point-in-polygon -->
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <!-- togeojson para convertir KML a GeoJSON -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>

  <script>
    // -----------------------------
    // Utilitarios
    // -----------------------------
    function getParam(name) {
      const url = new URL(window.location.href);
      return url.searchParams.get(name);
    }

    function nombreRegionAmigable(codigo) {
      if (codigo === "02") return "02 - Antofagasta";
      if (codigo === "03") return "03 - Atacama";
      if (codigo === "RM" || codigo === "13") return "RM - Metropolitana";
      return codigo || "--";
    }

    function normalizarListado(listadoJson) {
      // Devuelve array de objetos { archivo, nombre }
      let entradas = [];

      if (Array.isArray(listadoJson)) {
        // ["IPT_....kml", ...]
        entradas = listadoJson.map(x => ({
          archivo: x,
          nombre: x
        }));
      } else if (Array.isArray(listadoJson.kml)) {
        // { kml: [ "IPT_...kml", ... ] }
        entradas = listadoJson.kml.map(x => ({
          archivo: x,
          nombre: x
        }));
      } else if (Array.isArray(listadoJson.instrumentos)) {
        // { instrumentos: [ {archivo, nombre, ...}, ... ] }
        entradas = listadoJson.instrumentos.map(obj => ({
          archivo: obj.archivo || obj.kml || obj.nombre || "",
          nombre: obj.nombre || obj.archivo || obj.kml || ""
        }));
      } else {
        console.warn("Formato no reconocido de listado.json:", listadoJson);
      }

      // Filtrar vacíos y limpiar extensión del nombre solo visualmente
      return entradas
        .filter(e => e.archivo)
        .map(e => ({
          archivo: e.archivo,
          nombre: (e.nombre || e.archivo).replace(/\.kml$/i, "")
        }));
    }

    // -----------------------------
    // Mapa
    // -----------------------------
    let map;
    let markerPunto;
    let capaResultados;

    function initMap(lat, lon) {
      map = L.map("map", {
        center: [lat, lon],
        zoom: 14,
        minZoom: 4,
        maxZoom: 19
      });

      const osm = L.tileLayer(
        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        {
          maxZoom: 19,
          attribution: '&copy; OpenStreetMap contributors'
        }
      ).addTo(map);

      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution:
            "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, and the GIS User Community"
        }
      );

      L.control.layers(
        { "Mapa calle": osm, "Satélite": esriSat },
        {},
        { position: "topright" }
      ).addTo(map);

      markerPunto = L.circleMarker([lat, lon], {
        radius: 6,
        color: "#38bdf8",
        weight: 2,
        fillColor: "#0ea5e9",
        fillOpacity: 0.8
      }).addTo(map);

      capaResultados = L.featureGroup().addTo(map);
    }

    // -----------------------------
    // Motor de evaluación
    // -----------------------------
    async function evaluarPunto(lat, lon, regionCode) {
      const resumenEl = document.getElementById("instrumentos-resumen");
      const detalleEl = document.getElementById("detalle-atributos");

      if (!regionCode) {
        resumenEl.textContent = "No se especificó región en la URL.";
        detalleEl.textContent = "Sin región no es posible determinar qué KML consultar.";
        return;
      }

      const basePath = `capas/capas_${regionCode}/`;
      const listadoUrl = `${basePath}listado.json`;

      try {
        const listadoResp = await fetch(listadoUrl);
        if (!listadoResp.ok) {
          resumenEl.textContent = `No se encontró listado.json para la región ${regionCode}.`;
          detalleEl.textContent = "Verifique la carpeta de capas correspondiente.";
          return;
        }

        const listadoJson = await listadoResp.json();
        const instrumentos = normalizarListado(listadoJson);

        if (!instrumentos.length) {
          resumenEl.textContent = "No se encontraron instrumentos declarados en listado.json.";
          detalleEl.textContent = "Revise el contenido de listado.json.";
          return;
        }

        const punto = turf.point([lon, lat]);
        const coincidencias = []; // { archivo, nombreInstrumento, properties, feature }

        for (const inst of instrumentos) {
          const kmlUrl = basePath + inst.archivo;

          try {
            const kmlResp = await fetch(kmlUrl);
            if (!kmlResp.ok) {
              console.warn("No se pudo leer KML:", kmlUrl);
              continue;
            }
            const kmlText = await kmlResp.text();
            const xml = new DOMParser().parseFromString(kmlText, "application/xml");
            const geojson = toGeoJSON.kml(xml);

            if (!geojson || !Array.isArray(geojson.features)) continue;

            for (const feature of geojson.features) {
              if (!feature.geometry) continue;

              const geomType = feature.geometry.type;
              if (geomType !== "Polygon" && geomType !== "MultiPolygon") {
                continue;
              }

              const dentro = turf.booleanPointInPolygon(punto, feature);
              if (dentro) {
                coincidencias.push({
                  archivo: inst.archivo,
                  nombreInstrumento: inst.nombre,
                  properties: feature.properties || {},
                  feature
                });
              }
            }
          } catch (errKml) {
            console.warn("Error procesando KML:", kmlUrl, errKml);
          }
        }

        if (!coincidencias.length) {
          resumenEl.innerHTML = `
            <p class="no-match">
              No se encontró intersección del punto consultado con los polígonos
              de los instrumentos declarados en <code>listado.json</code> para la región ${regionCode}.
            </p>
          `;
          detalleEl.textContent = "No hay atributos que mostrar.";
          return;
        }

        // --- Resumen de instrumentos ---
        const instrumentosUnicos = Array.from(
          new Map(
            coincidencias.map(c => [
              c.archivo,
              {
                archivo: c.archivo,
                nombre: (c.nombreInstrumento || c.archivo).replace(/\.kml$/i, "")
              }
            ])
          ).values()
        );

        resumenEl.innerHTML = `
          <p class="small">El punto consultado se encuentra dentro de los siguientes instrumentos:</p>
          <div style="margin-top:4px;">
            ${instrumentosUnicos
              .map(
                inst => `<span class="pill">${inst.nombre}</span>`
              )
              .join("")}
          </div>
        `;

        // --- Atributos: tomamos la primera coincidencia por ahora ---
        const primera = coincidencias[0];
        const props = primera.properties || {};
        const claves = Object.keys(props);

        if (!claves.length) {
          detalleEl.innerHTML = `
            <p class="small">
              Se encontró intersección con ${instrumentosUnicos.length} instrumento(s),
              pero el KML no contiene atributos legibles en los campos estándar.
            </p>
          `;
        } else {
          let filas = "";
          claves.forEach((key) => {
            const valor = props[key];
            filas += `
              <tr>
                <th>${key}</th>
                <td>${valor}</td>
              </tr>
            `;
          });

          detalleEl.innerHTML = `
            <p class="small">
              Atributos del primer polígono que contiene el punto (puede haber más de un polígono e instrumento).
            </p>
            <table>
              <tbody>
                ${filas}
              </tbody>
            </table>
          `;
        }

        // --- Dibujo en el mapa ---
        capaResultados.clearLayers();
        const geometries = coincidencias.map(c => c.feature);
        geometries.forEach((feat) => {
          const layer = L.geoJSON(feat, {
            style: {
              color: "#60a5fa",
              weight: 2,
              fillColor: "#3b82f6",
              fillOpacity: 0.25
            }
          });
          capaResultados.addLayer(layer);
        });

        // Ajustar vista
        const bounds = capaResultados.getBounds();
        if (bounds.isValid()) {
          const boundsExtendidos = bounds.extend(markerPunto.getLatLng());
          map.fitBounds(boundsExtendidos, { padding: [20, 20] });
        }

      } catch (err) {
        console.error("Error general en la evaluación:", err);
        resumenEl.textContent = "Ocurrió un error al procesar la consulta.";
        detalleEl.textContent =
          "Revise la consola del navegador para más detalles (F12 → Console).";
      }
    }

    // -----------------------------
    // Inicialización global
    // -----------------------------
    document.addEventListener("DOMContentLoaded", () => {
      const latParam = parseFloat(getParam("lat") || "-27.0");
      const lonParam = parseFloat(getParam("lon") || "-70.0");
      const regionCode = getParam("region") || "--";

      document.getElementById("lat-display").textContent = latParam.toFixed(6);
      document.getElementById("lon-display").textContent = lonParam.toFixed(6);
      document.getElementById("region-display").textContent = nombreRegionAmigable(regionCode);

      initMap(latParam, lonParam);
      evaluarPunto(latParam, lonParam, regionCode);
    });
  </script>
</body>
</html>
